Elm.Chess = Elm.Chess || {};
Elm.Chess.Board = Elm.Chess.Board || {};
Elm.Chess.Board.make = function (_elm) {
   "use strict";
   _elm.Chess = _elm.Chess || {};
   _elm.Chess.Board = _elm.Chess.Board || {};
   if (_elm.Chess.Board.values)
   return _elm.Chess.Board.values;
   var _op = {},
   _N = Elm.Native,
   _U = _N.Utils.make(_elm),
   _L = _N.List.make(_elm),
   $moduleName = "Chess.Board",
   $Basics = Elm.Basics.make(_elm),
   $Chess$Color = Elm.Chess.Color.make(_elm),
   $Chess$Piece = Elm.Chess.Piece.make(_elm),
   $Dict = Elm.Dict.make(_elm),
   $List = Elm.List.make(_elm),
   $List$Extra = Elm.List.Extra.make(_elm),
   $Maybe = Elm.Maybe.make(_elm),
   $Maybe$Extra = Elm.Maybe.Extra.make(_elm),
   $Result = Elm.Result.make(_elm),
   $Signal = Elm.Signal.make(_elm);
   var numToChar = function (num) {
      return $Maybe.map($Basics.snd)(A2($List$Extra.find,
      function (_v0) {
         return function () {
            switch (_v0.ctor)
            {case "_Tuple2":
               return _U.eq(_v0._0,num);}
            _U.badCase($moduleName,
            "on line 303, column 28 to 39");
         }();
      },
      _L.fromArray([{ctor: "_Tuple2"
                    ,_0: 1
                    ,_1: _U.chr("A")}
                   ,{ctor: "_Tuple2"
                    ,_0: 2
                    ,_1: _U.chr("B")}
                   ,{ctor: "_Tuple2"
                    ,_0: 3
                    ,_1: _U.chr("C")}
                   ,{ctor: "_Tuple2"
                    ,_0: 4
                    ,_1: _U.chr("D")}
                   ,{ctor: "_Tuple2"
                    ,_0: 5
                    ,_1: _U.chr("E")}
                   ,{ctor: "_Tuple2"
                    ,_0: 6
                    ,_1: _U.chr("F")}
                   ,{ctor: "_Tuple2"
                    ,_0: 7
                    ,_1: _U.chr("G")}
                   ,{ctor: "_Tuple2"
                    ,_0: 8
                    ,_1: _U.chr("H")}])));
   };
   var charToNum = function ($char) {
      return $Maybe.map($Basics.snd)(A2($List$Extra.find,
      function (_v4) {
         return function () {
            switch (_v4.ctor)
            {case "_Tuple2":
               return _U.eq(_v4._0,$char);}
            _U.badCase($moduleName,
            "on line 292, column 29 to 42");
         }();
      },
      _L.fromArray([{ctor: "_Tuple2"
                    ,_0: _U.chr("A")
                    ,_1: 1}
                   ,{ctor: "_Tuple2"
                    ,_0: _U.chr("B")
                    ,_1: 2}
                   ,{ctor: "_Tuple2"
                    ,_0: _U.chr("C")
                    ,_1: 3}
                   ,{ctor: "_Tuple2"
                    ,_0: _U.chr("D")
                    ,_1: 4}
                   ,{ctor: "_Tuple2"
                    ,_0: _U.chr("E")
                    ,_1: 5}
                   ,{ctor: "_Tuple2"
                    ,_0: _U.chr("F")
                    ,_1: 6}
                   ,{ctor: "_Tuple2"
                    ,_0: _U.chr("G")
                    ,_1: 7}
                   ,{ctor: "_Tuple2"
                    ,_0: _U.chr("H")
                    ,_1: 8}])));
   };
   var getCastlingIntermediatePositions = function (turn) {
      return function () {
         switch (turn.ctor)
         {case "Black":
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: {ctor: "_Tuple2"
                             ,_0: _U.chr("B")
                             ,_1: 8}
                        ,_1: {ctor: "_Tuple2"
                             ,_0: _U.chr("C")
                             ,_1: 8}}
                   ,_1: {ctor: "_Tuple2"
                        ,_0: {ctor: "_Tuple2"
                             ,_0: _U.chr("F")
                             ,_1: 8}
                        ,_1: {ctor: "_Tuple2"
                             ,_0: _U.chr("G")
                             ,_1: 8}}};
            case "White":
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: {ctor: "_Tuple2"
                             ,_0: _U.chr("B")
                             ,_1: 1}
                        ,_1: {ctor: "_Tuple2"
                             ,_0: _U.chr("C")
                             ,_1: 1}}
                   ,_1: {ctor: "_Tuple2"
                        ,_0: {ctor: "_Tuple2"
                             ,_0: _U.chr("F")
                             ,_1: 1}
                        ,_1: {ctor: "_Tuple2"
                             ,_0: _U.chr("G")
                             ,_1: 1}}};}
         _U.badCase($moduleName,
         "between lines 166 and 171");
      }();
   };
   var getRookInitialPosition = function (turn) {
      return function () {
         switch (turn.ctor)
         {case "Black":
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: _U.chr("A")
                        ,_1: 8}
                   ,_1: {ctor: "_Tuple2"
                        ,_0: _U.chr("H")
                        ,_1: 8}};
            case "White":
            return {ctor: "_Tuple2"
                   ,_0: {ctor: "_Tuple2"
                        ,_0: _U.chr("A")
                        ,_1: 1}
                   ,_1: {ctor: "_Tuple2"
                        ,_0: _U.chr("H")
                        ,_1: 1}};}
         _U.badCase($moduleName,
         "between lines 156 and 161");
      }();
   };
   var takeWhileInclusive = F2(function (predicate,
   xs) {
      return function () {
         switch (xs.ctor)
         {case "::":
            return A2($List._op["::"],
              xs._0,
              predicate(xs._0) ? A2(takeWhileInclusive,
              predicate,
              xs._1) : _L.fromArray([]));
            case "[]":
            return _L.fromArray([]);}
         _U.badCase($moduleName,
         "between lines 147 and 152");
      }();
   });
   var pawnTakeRanges = function (color) {
      return function () {
         switch (color.ctor)
         {case "Black": return {_: {}
                               ,left: {ctor: "_Tuple2"
                                      ,_0: -1
                                      ,_1: -1}
                               ,right: {ctor: "_Tuple2"
                                       ,_0: 1
                                       ,_1: -1}};
            case "White": return {_: {}
                                 ,left: {ctor: "_Tuple2"
                                        ,_0: -1
                                        ,_1: 1}
                                 ,right: {ctor: "_Tuple2"
                                         ,_0: 1
                                         ,_1: 1}};}
         _U.badCase($moduleName,
         "between lines 137 and 142");
      }();
   };
   var shift = F2(function (_v14,
   _v15) {
      return function () {
         switch (_v15.ctor)
         {case "_Tuple2":
            return function () {
                 switch (_v14.ctor)
                 {case "_Tuple2":
                    return function () {
                         var charNumericalRepresentation = function () {
                            var _v22 = charToNum(_v14._0);
                            switch (_v22.ctor)
                            {case "Just": return _v22._0;
                               case "Nothing": return -10000;}
                            _U.badCase($moduleName,
                            "between lines 87 and 95");
                         }();
                         var shiftedCharNumericalRepresentation = charNumericalRepresentation + _v15._0;
                         var shiftedChar = function () {
                            var _v24 = numToChar(shiftedCharNumericalRepresentation);
                            switch (_v24.ctor)
                            {case "Just": return _v24._0;
                               case "Nothing":
                               return _U.chr("!");}
                            _U.badCase($moduleName,
                            "between lines 99 and 106");
                         }();
                         return {ctor: "_Tuple2"
                                ,_0: shiftedChar
                                ,_1: _v14._1 + _v15._1};
                      }();}
                 _U.badCase($moduleName,
                 "between lines 85 and 107");
              }();}
         _U.badCase($moduleName,
         "between lines 85 and 107");
      }();
   });
   var getHorizontalAdjacentPositions = function (position) {
      return {ctor: "_Tuple2"
             ,_0: A2(shift,
             position,
             {ctor: "_Tuple2",_0: 1,_1: 0})
             ,_1: A2(shift,
             position,
             {ctor: "_Tuple2"
             ,_0: -1
             ,_1: 0})};
   };
   var positionAhead = F2(function (color,
   position) {
      return function () {
         switch (color.ctor)
         {case "Black": return A2(shift,
              position,
              {ctor: "_Tuple2",_0: 0,_1: -1});
            case "White": return A2(shift,
              position,
              {ctor: "_Tuple2",_0: 0,_1: 1});}
         _U.badCase($moduleName,
         "between lines 117 and 121");
      }();
   });
   var positionBelow = F2(function (color,
   position) {
      return function () {
         switch (color.ctor)
         {case "Black": return A2(shift,
              position,
              {ctor: "_Tuple2",_0: 0,_1: 1});
            case "White": return A2(shift,
              position,
              {ctor: "_Tuple2"
              ,_0: 0
              ,_1: -1});}
         _U.badCase($moduleName,
         "between lines 126 and 130");
      }();
   });
   var emptyRow = A2($List.repeat,
   8,
   $Maybe.Nothing);
   var getSquareContent = function (board) {
      return function ($) {
         return $Maybe$Extra.join(A2($Basics.flip,
         $Dict.get,
         board)($));
      };
   };
   var rangeToSquare = F2(function (position,
   board) {
      return function ($) {
         return getSquareContent(board)(shift(position)($));
      };
   });
   var isPopulated = F2(function (board,
   position) {
      return function ($) {
         return $Maybe$Extra.isJust(A2(rangeToSquare,
         position,
         board)($));
      };
   });
   var letters = _L.fromArray([_U.chr("A")
                              ,_U.chr("B")
                              ,_U.chr("C")
                              ,_U.chr("D")
                              ,_U.chr("E")
                              ,_U.chr("F")
                              ,_U.chr("G")
                              ,_U.chr("H")]);
   var getPositions = $List.concat(A2($List.map,
   function (digit) {
      return A2($List.map,
      function (letter) {
         return {ctor: "_Tuple2"
                ,_0: letter
                ,_1: digit};
      },
      letters);
   },
   _L.range(1,8)));
   var makeInitialBoard = function () {
      var zip$ = function (_v28) {
         return function () {
            switch (_v28.ctor)
            {case "_Tuple2":
               return A2($List$Extra.zip,
                 _v28._0,
                 _v28._1);}
            _U.badCase($moduleName,
            "on line 69, column 26 to 39");
         }();
      };
      var makeRow = function (number) {
         return A2($List$Extra.zip,
         letters,
         A2($List.repeat,8,number));
      };
      var makeFirstRow = function (color) {
         return A2($List.map,
         function ($) {
            return $Maybe.Just(A2($Basics.flip,
            $Chess$Piece.piece,
            color)($));
         },
         _L.fromArray([$Chess$Piece.Rook
                      ,$Chess$Piece.Knight
                      ,$Chess$Piece.Bishop
                      ,$Chess$Piece.Queen
                      ,$Chess$Piece.King
                      ,$Chess$Piece.Bishop
                      ,$Chess$Piece.Knight
                      ,$Chess$Piece.Rook]));
      };
      var pawnRow = function (pawnColor) {
         return $List.repeat(8)($Maybe.Just(A2($Chess$Piece.piece,
         $Chess$Piece.Pawn,
         pawnColor)));
      };
      return $Dict.fromList($List.concat(A2($List.map,
      zip$,
      _L.fromArray([{ctor: "_Tuple2"
                    ,_0: makeRow(8)
                    ,_1: makeFirstRow($Chess$Color.Black)}
                   ,{ctor: "_Tuple2"
                    ,_0: makeRow(7)
                    ,_1: pawnRow($Chess$Color.Black)}
                   ,{ctor: "_Tuple2"
                    ,_0: makeRow(6)
                    ,_1: emptyRow}
                   ,{ctor: "_Tuple2"
                    ,_0: makeRow(5)
                    ,_1: emptyRow}
                   ,{ctor: "_Tuple2"
                    ,_0: makeRow(4)
                    ,_1: emptyRow}
                   ,{ctor: "_Tuple2"
                    ,_0: makeRow(3)
                    ,_1: emptyRow}
                   ,{ctor: "_Tuple2"
                    ,_0: makeRow(2)
                    ,_1: pawnRow($Chess$Color.White)}
                   ,{ctor: "_Tuple2"
                    ,_0: makeRow(1)
                    ,_1: makeFirstRow($Chess$Color.White)}]))));
   }();
   var filterPositions = function (positions) {
      return function () {
         var filterPosition = function (pos) {
            return A2($List.member,
            $Basics.fst(pos),
            letters) && A2($List.member,
            $Basics.snd(pos),
            _L.range(1,8));
         };
         return $List.filter(filterPosition)(positions);
      }();
   };
   var getRegularDestinations = F4(function (turn,
   board,
   piece,
   position) {
      return function () {
         var kingMoves = _L.fromArray([{ctor: "_Tuple2"
                                       ,_0: 0
                                       ,_1: 1}
                                      ,{ctor: "_Tuple2",_0: 1,_1: 1}
                                      ,{ctor: "_Tuple2",_0: 1,_1: 0}
                                      ,{ctor: "_Tuple2",_0: 1,_1: -1}
                                      ,{ctor: "_Tuple2",_0: 0,_1: -1}
                                      ,{ctor: "_Tuple2",_0: -1,_1: -1}
                                      ,{ctor: "_Tuple2",_0: -1,_1: 0}
                                      ,{ctor: "_Tuple2"
                                       ,_0: -1
                                       ,_1: 1}]);
         var takeWhileEmpty = function (rangesInclusive) {
            return A2(takeWhileInclusive,
            function ($) {
               return $Maybe$Extra.isNothing(A2(rangeToSquare,
               position,
               board)($));
            },
            rangesInclusive);
         };
         var takeWhileEmpty$ = function (_v32) {
            return function () {
               switch (_v32.ctor)
               {case "_Tuple2":
                  return takeWhileEmpty(A2($List$Extra.zip,
                    _v32._0,
                    _v32._1));}
               _U.badCase($moduleName,
               "on line 213, column 7 to 32");
            }();
         };
         var getDirectionalMoves = function (directions) {
            return $List.concat(A2($List.map,
            takeWhileEmpty$,
            directions));
         };
         var negativeOneToSeven = $List.reverse(_L.range(-7,
         -1));
         var oneToSeven = _L.range(1,7);
         var bishopMoves = getDirectionalMoves(_L.fromArray([{ctor: "_Tuple2"
                                                             ,_0: oneToSeven
                                                             ,_1: oneToSeven}
                                                            ,{ctor: "_Tuple2"
                                                             ,_0: negativeOneToSeven
                                                             ,_1: oneToSeven}
                                                            ,{ctor: "_Tuple2"
                                                             ,_0: oneToSeven
                                                             ,_1: negativeOneToSeven}
                                                            ,{ctor: "_Tuple2"
                                                             ,_0: negativeOneToSeven
                                                             ,_1: negativeOneToSeven}]));
         var zeros = A2($List.repeat,
         7,
         0);
         var rookMoves = getDirectionalMoves(_L.fromArray([{ctor: "_Tuple2"
                                                           ,_0: oneToSeven
                                                           ,_1: zeros}
                                                          ,{ctor: "_Tuple2"
                                                           ,_0: negativeOneToSeven
                                                           ,_1: zeros}
                                                          ,{ctor: "_Tuple2"
                                                           ,_0: zeros
                                                           ,_1: oneToSeven}
                                                          ,{ctor: "_Tuple2"
                                                           ,_0: zeros
                                                           ,_1: negativeOneToSeven}]));
         var ranges = function () {
            var _v36 = piece.figure;
            switch (_v36.ctor)
            {case "Bishop":
               return bishopMoves;
               case "King": return kingMoves;
               case "Knight":
               return _L.fromArray([{ctor: "_Tuple2"
                                    ,_0: 1
                                    ,_1: 2}
                                   ,{ctor: "_Tuple2",_0: -1,_1: 2}
                                   ,{ctor: "_Tuple2",_0: 2,_1: 1}
                                   ,{ctor: "_Tuple2",_0: 2,_1: -1}
                                   ,{ctor: "_Tuple2",_0: 1,_1: -2}
                                   ,{ctor: "_Tuple2",_0: -1,_1: -2}
                                   ,{ctor: "_Tuple2",_0: -2,_1: 1}
                                   ,{ctor: "_Tuple2"
                                    ,_0: -2
                                    ,_1: -1}]);
               case "Pawn":
               return function () {
                    var isPopulated$ = A2(isPopulated,
                    board,
                    position);
                    var verticalDestinations = F2(function (oneSquareAhead,
                    twoSquaresAhead) {
                       return isPopulated$(oneSquareAhead) ? _L.fromArray([]) : isPopulated$(twoSquaresAhead) ? _L.fromArray([oneSquareAhead]) : piece.moved ? _L.fromArray([oneSquareAhead]) : _L.fromArray([oneSquareAhead
                                                                                                                                                                                                             ,twoSquaresAhead]);
                    });
                    return function () {
                       var _v37 = piece.color;
                       switch (_v37.ctor)
                       {case "Black":
                          return A2(verticalDestinations,
                            {ctor: "_Tuple2",_0: 0,_1: -1},
                            {ctor: "_Tuple2",_0: 0,_1: -2});
                          case "White":
                          return A2(verticalDestinations,
                            {ctor: "_Tuple2",_0: 0,_1: 1},
                            {ctor: "_Tuple2",_0: 0,_1: 2});}
                       _U.badCase($moduleName,
                       "between lines 275 and 284");
                    }();
                 }();
               case "Queen":
               return A2($Basics._op["++"],
                 bishopMoves,
                 rookMoves);
               case "Rook": return rookMoves;}
            _U.badCase($moduleName,
            "between lines 241 and 284");
         }();
         return filterPositions(A2($List.map,
         shift(position),
         ranges));
      }();
   });
   _elm.Chess.Board.values = {_op: _op
                             ,letters: letters
                             ,getPositions: getPositions
                             ,getSquareContent: getSquareContent
                             ,emptyRow: emptyRow
                             ,makeInitialBoard: makeInitialBoard
                             ,shift: shift
                             ,getHorizontalAdjacentPositions: getHorizontalAdjacentPositions
                             ,positionAhead: positionAhead
                             ,positionBelow: positionBelow
                             ,pawnTakeRanges: pawnTakeRanges
                             ,takeWhileInclusive: takeWhileInclusive
                             ,getRookInitialPosition: getRookInitialPosition
                             ,getCastlingIntermediatePositions: getCastlingIntermediatePositions
                             ,filterPositions: filterPositions
                             ,rangeToSquare: rangeToSquare
                             ,isPopulated: isPopulated
                             ,getRegularDestinations: getRegularDestinations
                             ,charToNum: charToNum
                             ,numToChar: numToChar};
   return _elm.Chess.Board.values;
};